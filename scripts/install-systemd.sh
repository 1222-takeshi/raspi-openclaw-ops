#!/usr/bin/env bash
set -euo pipefail

APP_DIR=${APP_DIR:-/opt/raspi-openclaw-ops}
SERVICE_NAME=${SERVICE_NAME:-raspi-openclaw-ops}

# Optional: load local config (gitignored)
# Default: config/.env.local
DOTENV_FILE=${DOTENV_FILE:-config/.env.local}

# systemd env file (recommended to avoid leaking secrets in `systemctl show`)
ENV_FILE=${ENV_FILE:-/etc/default/${SERVICE_NAME}}

# Optional overrides (written to ENV_FILE)
PORT=${PORT:-}
HOST=${HOST:-}
TIME_ZONE=${TIME_ZONE:-}
CPU_TEMP_WARN_C=${CPU_TEMP_WARN_C:-}
DISK_USED_WARN_PCT=${DISK_USED_WARN_PCT:-}
METRICS_INTERVAL_MS=${METRICS_INTERVAL_MS:-}

CLAWDBOT_SERVICE=${CLAWDBOT_SERVICE:-}
CLAWDBOT_PROCESS_PATTERNS=${CLAWDBOT_PROCESS_PATTERNS:-}
STATUS_TOKEN=${STATUS_TOKEN:-}

if [[ $EUID -eq 0 ]]; then
  echo "Do not run as root. Run as a normal user with sudo available." >&2
  exit 1
fi

# Safety: encourage running from a git working tree (prevents deploying random /opt contents).
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "ERROR: This script should be run from a git working tree (e.g. ~/src/raspi-openclaw-ops)." >&2
  echo "       Current directory is not a git repo." >&2
  echo "       If you really know what you're doing, set ALLOW_NO_GIT=1." >&2
  if [[ "${ALLOW_NO_GIT:-}" != "1" ]]; then
    exit 2
  fi
fi

# Warn if not on main (common cause of deploying outdated code)
branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
if [[ -n "${branch}" && "${branch}" != "main" ]]; then
  echo "WARNING: current git branch is '${branch}'. You may deploy non-latest code." >&2
  echo "         (recommended: git checkout main && git pull)" >&2
fi

if [[ -f "${DOTENV_FILE}" ]]; then
  echo "==> Loading dotenv: ${DOTENV_FILE}" >&2
  # shellcheck disable=SC1090
  set -a
  source "${DOTENV_FILE}"
  set +a
fi

# Re-read after dotenv
PORT=${PORT:-}
HOST=${HOST:-}
TIME_ZONE=${TIME_ZONE:-}
CPU_TEMP_WARN_C=${CPU_TEMP_WARN_C:-}
DISK_USED_WARN_PCT=${DISK_USED_WARN_PCT:-}
METRICS_INTERVAL_MS=${METRICS_INTERVAL_MS:-}

CLAWDBOT_SERVICE=${CLAWDBOT_SERVICE:-}
CLAWDBOT_PROCESS_PATTERNS=${CLAWDBOT_PROCESS_PATTERNS:-}
STATUS_TOKEN=${STATUS_TOKEN:-}

if [[ -n "${CLAWDBOT_SERVICE}" && -n "${CLAWDBOT_PROCESS_PATTERNS}" ]]; then
  echo "ERROR: Set only one of CLAWDBOT_SERVICE or CLAWDBOT_PROCESS_PATTERNS." >&2
  exit 2
fi

echo "==> Installing to: ${APP_DIR}" >&2
sudo mkdir -p "${APP_DIR}"
sudo mkdir -p "${APP_DIR}/data"
sudo chown -R "$USER:$USER" "${APP_DIR}"

echo "==> Syncing files" >&2
rsync -a --delete \
  --exclude node_modules \
  --exclude dist \
  --exclude .git \
  ./ "${APP_DIR}/"

echo "==> Installing dependencies & building" >&2
cd "${APP_DIR}"
npm ci --include=dev
npm run build

echo "==> Installing systemd unit" >&2
sudo cp "${APP_DIR}/systemd/${SERVICE_NAME}.service" "/etc/systemd/system/${SERVICE_NAME}.service"

# Write systemd EnvironmentFile if any relevant variables are provided.
# Also inject build metadata from current git checkout.
GIT_SHA=$(git rev-parse --short=12 HEAD 2>/dev/null || true)
# Prefer exact tag, fallback to branch name
GIT_REF=$(git describe --tags --exact-match 2>/dev/null || git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
BUILD_TIME=$(date -Is 2>/dev/null || true)
APP_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || true)

OVERRIDE_DIR="/etc/systemd/system/${SERVICE_NAME}.service.d"
OVERRIDE_FILE="${OVERRIDE_DIR}/override.conf"

if [[ -n "${PORT}" || -n "${HOST}" || -n "${TIME_ZONE}" || -n "${CPU_TEMP_WARN_C}" || -n "${DISK_USED_WARN_PCT}" || -n "${METRICS_INTERVAL_MS}" || -n "${CLAWDBOT_SERVICE}" || -n "${CLAWDBOT_PROCESS_PATTERNS}" || -n "${STATUS_TOKEN}" ]]; then
  echo "==> Writing systemd env file: ${ENV_FILE}" >&2
  tmpenv=$(mktemp)
  {
    echo "# Generated by ${SERVICE_NAME} install script"
    [[ -n "${PORT}" ]] && echo "PORT=${PORT}"
    [[ -n "${HOST}" ]] && echo "HOST=${HOST}"
    [[ -n "${TIME_ZONE}" ]] && echo "TIME_ZONE=${TIME_ZONE}"
    [[ -n "${CPU_TEMP_WARN_C}" ]] && echo "CPU_TEMP_WARN_C=${CPU_TEMP_WARN_C}"
    [[ -n "${DISK_USED_WARN_PCT}" ]] && echo "DISK_USED_WARN_PCT=${DISK_USED_WARN_PCT}"
    [[ -n "${METRICS_INTERVAL_MS}" ]] && echo "METRICS_INTERVAL_MS=${METRICS_INTERVAL_MS}"

    [[ -n "${CLAWDBOT_SERVICE}" ]] && echo "CLAWDBOT_SERVICE=${CLAWDBOT_SERVICE}"
    [[ -n "${CLAWDBOT_PROCESS_PATTERNS}" ]] && echo "CLAWDBOT_PROCESS_PATTERNS=${CLAWDBOT_PROCESS_PATTERNS}"
    [[ -n "${STATUS_TOKEN}" ]] && echo "STATUS_TOKEN=${STATUS_TOKEN}"

    # build metadata
    [[ -n "${APP_VERSION}" ]] && echo "APP_VERSION=${APP_VERSION}"
    [[ -n "${GIT_REF}" ]] && echo "GIT_REF=${GIT_REF}"
    [[ -n "${GIT_SHA}" ]] && echo "GIT_SHA=${GIT_SHA}"
    [[ -n "${BUILD_TIME}" ]] && echo "BUILD_TIME=${BUILD_TIME}"
  } >"${tmpenv}"
  sudo install -m 0640 -o root -g root "${tmpenv}" "${ENV_FILE}"
  rm -f "${tmpenv}"

  echo "==> Writing systemd override: ${OVERRIDE_FILE}" >&2
  sudo mkdir -p "${OVERRIDE_DIR}"
  tmpovr=$(mktemp)
  {
    echo "[Service]"
    echo "EnvironmentFile=${ENV_FILE}"
  } >"${tmpovr}"
  sudo cp "${tmpovr}" "${OVERRIDE_FILE}"
  rm -f "${tmpovr}"
else
  echo "==> No overrides provided; skipping envfile/drop-in generation" >&2
fi

sudo systemctl daemon-reload

echo "==> Restarting service" >&2
# enable does not necessarily restart an already-running service; restart explicitly.
sudo systemctl enable "${SERVICE_NAME}" >/dev/null
sudo systemctl restart "${SERVICE_NAME}"

# Post-check
CHECK_PORT=${PORT:-8080}

echo "==> Verifying" >&2
sudo systemctl --no-pager -l status "${SERVICE_NAME}" | sed -n '1,16p' >&2 || true

# 1) service active
if ! sudo systemctl is-active --quiet "${SERVICE_NAME}"; then
  echo "ERROR: service is not active" >&2
  exit 3
fi

# 2) port listening
if command -v ss >/dev/null 2>&1; then
  if ! sudo ss -ltnp | grep -q ":${CHECK_PORT} "; then
    echo "ERROR: port ${CHECK_PORT} is not listening" >&2
    sudo ss -ltnp | sed -n '1,80p' >&2 || true
    exit 3
  fi
  echo "==> Listen check" >&2
  sudo ss -ltnp | grep ":${CHECK_PORT} " >&2 || true
fi

# 3) endpoint check (200 or 401 expected)
if command -v curl >/dev/null 2>&1; then
  url="http://127.0.0.1:${CHECK_PORT}/health.json"
  echo "==> Checking health endpoint: ${url}" >&2
  code=$(curl -sS -o /dev/null -w "%{http_code}" "${url}" || echo "000")
  if [[ "${code}" != "200" && "${code}" != "401" ]]; then
    echo "ERROR: unexpected status code: ${code}" >&2
    curl -sS -i "${url}" | head -n 20 >&2 || true
    exit 3
  fi
  echo "==> health.json status: ${code}" >&2
fi

echo "==> Done" >&2
echo "- Status: systemctl status ${SERVICE_NAME}" >&2
echo "- Logs:   journalctl -u ${SERVICE_NAME} -f" >&2
