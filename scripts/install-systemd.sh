#!/usr/bin/env bash
set -euo pipefail

APP_DIR=${APP_DIR:-/opt/raspi-openclaw-ops}
SERVICE_NAME=${SERVICE_NAME:-raspi-openclaw-ops}

# Optional: load local config (gitignored)
# Default: config/.env.local
DOTENV_FILE=${DOTENV_FILE:-config/.env.local}

# systemd env file (recommended to avoid leaking secrets in `systemctl show`)
ENV_FILE=${ENV_FILE:-/etc/default/${SERVICE_NAME}}

# Optional overrides (written to ENV_FILE)
PORT=${PORT:-}
HOST=${HOST:-}
TIME_ZONE=${TIME_ZONE:-}
CPU_TEMP_WARN_C=${CPU_TEMP_WARN_C:-}
DISK_USED_WARN_PCT=${DISK_USED_WARN_PCT:-}
METRICS_INTERVAL_MS=${METRICS_INTERVAL_MS:-}

CLAWDBOT_SERVICE=${CLAWDBOT_SERVICE:-}
CLAWDBOT_PROCESS_PATTERNS=${CLAWDBOT_PROCESS_PATTERNS:-}
STATUS_TOKEN=${STATUS_TOKEN:-}

if [[ $EUID -eq 0 ]]; then
  echo "Do not run as root. Run as a normal user with sudo available." >&2
  exit 1
fi

# Safety: encourage running from a git working tree (prevents deploying random /opt contents).
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "ERROR: This script should be run from a git working tree (e.g. ~/src/raspi-openclaw-ops)." >&2
  echo "       Current directory is not a git repo." >&2
  echo "       If you really know what you're doing, set ALLOW_NO_GIT=1." >&2
  if [[ "${ALLOW_NO_GIT:-}" != "1" ]]; then
    exit 2
  fi
fi

# Warn if not on main (common cause of deploying outdated code)
branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
if [[ -n "${branch}" && "${branch}" != "main" ]]; then
  echo "WARNING: current git branch is '${branch}'. You may deploy non-latest code." >&2
  echo "         (recommended: git checkout main && git pull)" >&2
fi

if [[ -f "${DOTENV_FILE}" ]]; then
  echo "==> Loading dotenv: ${DOTENV_FILE}" >&2
  # shellcheck disable=SC1090
  set -a
  source "${DOTENV_FILE}"
  set +a
fi

# Re-read after dotenv
PORT=${PORT:-}
HOST=${HOST:-}
TIME_ZONE=${TIME_ZONE:-}
CPU_TEMP_WARN_C=${CPU_TEMP_WARN_C:-}
DISK_USED_WARN_PCT=${DISK_USED_WARN_PCT:-}
METRICS_INTERVAL_MS=${METRICS_INTERVAL_MS:-}

CLAWDBOT_SERVICE=${CLAWDBOT_SERVICE:-}
CLAWDBOT_PROCESS_PATTERNS=${CLAWDBOT_PROCESS_PATTERNS:-}
STATUS_TOKEN=${STATUS_TOKEN:-}

if [[ -n "${CLAWDBOT_SERVICE}" && -n "${CLAWDBOT_PROCESS_PATTERNS}" ]]; then
  echo "ERROR: Set only one of CLAWDBOT_SERVICE or CLAWDBOT_PROCESS_PATTERNS." >&2
  exit 2
fi

echo "==> Installing to: ${APP_DIR}" >&2
sudo mkdir -p "${APP_DIR}"
sudo chown -R "$USER:$USER" "${APP_DIR}"

echo "==> Syncing files" >&2
rsync -a --delete \
  --exclude node_modules \
  --exclude dist \
  --exclude .git \
  ./ "${APP_DIR}/"

echo "==> Installing dependencies & building" >&2
cd "${APP_DIR}"
npm ci --include=dev
npm run build

echo "==> Installing systemd unit" >&2
sudo cp "${APP_DIR}/systemd/${SERVICE_NAME}.service" "/etc/systemd/system/${SERVICE_NAME}.service"

# Write systemd EnvironmentFile if any relevant variables are provided.
OVERRIDE_DIR="/etc/systemd/system/${SERVICE_NAME}.service.d"
OVERRIDE_FILE="${OVERRIDE_DIR}/override.conf"

if [[ -n "${PORT}" || -n "${HOST}" || -n "${TIME_ZONE}" || -n "${CPU_TEMP_WARN_C}" || -n "${DISK_USED_WARN_PCT}" || -n "${METRICS_INTERVAL_MS}" || -n "${CLAWDBOT_SERVICE}" || -n "${CLAWDBOT_PROCESS_PATTERNS}" || -n "${STATUS_TOKEN}" ]]; then
  echo "==> Writing systemd env file: ${ENV_FILE}" >&2
  tmpenv=$(mktemp)
  {
    echo "# Generated by ${SERVICE_NAME} install script"
    [[ -n "${PORT}" ]] && echo "PORT=${PORT}"
    [[ -n "${HOST}" ]] && echo "HOST=${HOST}"
    [[ -n "${TIME_ZONE}" ]] && echo "TIME_ZONE=${TIME_ZONE}"
    [[ -n "${CPU_TEMP_WARN_C}" ]] && echo "CPU_TEMP_WARN_C=${CPU_TEMP_WARN_C}"
    [[ -n "${DISK_USED_WARN_PCT}" ]] && echo "DISK_USED_WARN_PCT=${DISK_USED_WARN_PCT}"
    [[ -n "${METRICS_INTERVAL_MS}" ]] && echo "METRICS_INTERVAL_MS=${METRICS_INTERVAL_MS}"

    [[ -n "${CLAWDBOT_SERVICE}" ]] && echo "CLAWDBOT_SERVICE=${CLAWDBOT_SERVICE}"
    [[ -n "${CLAWDBOT_PROCESS_PATTERNS}" ]] && echo "CLAWDBOT_PROCESS_PATTERNS=${CLAWDBOT_PROCESS_PATTERNS}"
    [[ -n "${STATUS_TOKEN}" ]] && echo "STATUS_TOKEN=${STATUS_TOKEN}"
  } >"${tmpenv}"
  sudo install -m 0640 -o root -g root "${tmpenv}" "${ENV_FILE}"
  rm -f "${tmpenv}"

  echo "==> Writing systemd override: ${OVERRIDE_FILE}" >&2
  sudo mkdir -p "${OVERRIDE_DIR}"
  tmpovr=$(mktemp)
  {
    echo "[Service]"
    echo "EnvironmentFile=${ENV_FILE}"
  } >"${tmpovr}"
  sudo cp "${tmpovr}" "${OVERRIDE_FILE}"
  rm -f "${tmpovr}"
else
  echo "==> No overrides provided; skipping envfile/drop-in generation" >&2
fi

sudo systemctl daemon-reload
sudo systemctl enable --now "${SERVICE_NAME}"

# Post-check
echo "==> Verifying" >&2
sudo systemctl --no-pager -l status "${SERVICE_NAME}" | sed -n '1,12p' >&2 || true

CHECK_PORT=${PORT:-8080}
if command -v curl >/dev/null 2>&1; then
  echo "==> Checking health endpoint: http://127.0.0.1:${CHECK_PORT}/health.json" >&2
  # NOTE: If STATUS_TOKEN is set, this will likely return 401. That's expected.
  curl -sS -i "http://127.0.0.1:${CHECK_PORT}/health.json" | head -n 5 || true
  echo >&2
fi

echo "==> Done" >&2
echo "- Status: systemctl status ${SERVICE_NAME}" >&2
echo "- Logs:   journalctl -u ${SERVICE_NAME} -f" >&2
